{
  "name": "ee-class",
  "description": "A fast prototype based Javascript Class implementation",
  "version": "1.0.7",
  "homepage": "https://github.com/eventEmitter/ee-class",
  "author": {
    "name": "Michael van der Weg",
    "email": "michael@eventemitter.com",
    "url": "http://eventemitter.com/"
  },
  "licence": "mit",
  "repository": {
    "url": "https://github.com/eventEmitter/ee-class.git",
    "type": "git"
  },
  "engines": {
    "node": ">=v0.10.0"
  },
  "bugs": {
    "url": "https://github.com/eventEmitter/ee-class/issues"
  },
  "dependencies": {},
  "devDependencies": {
    "mocha": "1.17.x"
  },
  "optionalDependencies": {},
  "keywords": [
    "class"
  ],
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha --reporter spec"
  },
  "readme": "# ee-class\n\nA fast prototype based Javascript Class implementation\n\n## installation\n\n    npm install ee-class\n\n## build status\n\n[![Build Status](https://travis-ci.org/eventEmitter/ee-class.png?branch=master)](https://travis-ci.org/eventEmitter/ee-class)\n\n\n## API\n\nThe Class implementation is built on top of javascript prototype based inheritance and ECMA Script property descriptors.\n\n### Constructor\n    \nClasses can be created using the Class function. The function expects exactly one argument, the class definition.\n\n    var MyClass = new Class();\n\n### Class Definition\n\n#### «inherits» property\n\nObjects & Functions on this property are handled as the prototype for the prototype of the class you are creating.\n\n    var MyClass = new Class({\n        inherits: Array\n    }); \n\n    // { // MyClass instance\n    //      __proto__: { // MyClass protoype (where your items from the classdefinition are placed)\n    //         __proto__: { // the Array prototype\n    //              __proto__: {} // the prototype of the array prototype («[Object object]»)\n    //          }\n    //      }\n    // }\n\n\n#### «function type» properties\n\nFunctions will be placed on the Classes prototype object, they are by default not configurable, \nnot writeable and enumerable (except for properties starting with an «_». If the property has \nthe name «init» it is treated as the classes constructor.\n\n    var MyClass = new Class({\n        init: function(){\n            console.log('im executed when the class is instantiated');\n        }\n    });\n\n    var instance = new MyClass(); // im executed when the class is instantiated\n\n    console.dir(instance); // {} -> the init function is placed on the instances\n                           // prototype\n    console.log(intance.init); // { [Function: init] super: [Function] }\n    console.log(instance instanceof MyClass); // true\n    console.log(instance instanceof Object); // true\n    console.log(instance instanceof Date); // false\n\n\nNote the super property on the init function, it can be used to call the constructor of the next \nconstructor function in the prototype chain.\n\n\n#### Property Descriptors\n\nThe Class definition may contain property descriptor objects. You are able to create \nconfigure each of the properties exactly as you like. You can create getters and setters\nand configure the configurability, the writability and the enumerability.\n\n\n    var Person = new Class({\n        init: function(options){\n            if (options && options.name !== undefined)  this.name = options.name;\n            if (options && options.age !== undefined)   this.age = options.age;\n        }   \n\n        // the private storage for the age value\n        , _storage: {\n            value: {\n                age: null\n            }\n        }\n\n        , name: '' // enumerable, writable, not configurable\n\n        , age: {\n              get: function(){ return this._storage.age; }\n            , set: function(value) {\n                if (value < 0) throw new Error('Please provide an age >= 0!');\n                else if (value > 150) throw new Error('You are too old, sorry!');\n                else this._storage.age = value;\n            }\n            , enumerable: true\n            /* , configurable: false */ // defaults to false\n            /* , writable: false */ // defaults to false\n        }\n\n        , sayHelloTo: {\n            value: function(name){\n                console.log('Hello %s, my name is %s and im %s years old :)'\n                    , name, this.name, this.age);\n            }\n        }\n    });\n    \n    var instance = new Person({name: 'Michael', age: 30});\n    instance.sayHelloTo('Tobias'); // Hello Tobias, my name is Michael and im 30 \n                                   // years old :)\n\n    // Object keys hets all enumerable keys from the instance but not its \n    // prototypes\n    console.log(Object.keys(instance)); // [ 'name' ]\n\n    // Class.keys() gets all enumerable keys from the instance and all its \n    // prototypes\n    // Class.keys -> for (var key in instance) keys.push(key);\n    console.log(Class.keys(instance)); // [ 'name', 'init', 'age' ]\n\n\n    // internal structure of the Person instance\n    {\n          name: 'Michael'   // this was set from inside the constructor function\n        , __proto__: {      // the Person prototype\n              init: function(){ ... }\n            , _storage: {\n                age: 30     // set by the constructor, ATTENTION: this is shared \n                            // across all «Person» instances\n            }\n            , name: ''      // deafult wont be changed anytime\n            , age: [Getter / Setter]\n            , sayHelloTo: function(){ ... }\n            , __proto__: {} // default prototype \n        }\n    }\n\n\nThe example above has one problem. All instances of the «Person» class are going to share the «_storage» property.\nThis is because it's a property which will not be set on the instance itself but only once on the prototype. \nA Better solution would be the follwoing:\n\n     var Person = new Class({\n        init: function(options){\n            Object.defineProperty(this, '_storage', {value: {}});\n            Class.define(this, '_storage', {value: {}}); // alternative syntax\n            Class.define(this, '_storage', Class({})) // alternatove syntax\n\n           ....\n        }   \n\n        ...\n    });\n\n\n\n\n### Inheritance\n\nAny class may inherit from any oter class or builtin types.\n    \n    var LifeForm = new Class({\n        init: function(isAlive) {\n            Class.define(this, 'isAlive', Class(isAlive).Enumerable().Writable());\n        }\n\n        , isAlive: Class(false).Enumerable().Writable()\n    });\n\n\n    var Person = new Class({\n        inherits: LifeForm\n\n        , talk: function(){\n            console.log('Hi my name is %s, i\\'m '+(this.isAlive ? 'alive :)' \n                : 'dead :('), this.name);\n        }\n    });\n\n\n    var Boy = new Class({\n        inherits: Person\n\n        , init: function constructor(name, alive) {\n            // you need to give the function a name in order to be able to call \n            // its super. you must «call» or «apply» the super function to give\n            // it the correct context\n            constructor.super.call(this, alive);\n\n            this.name = Class.define(this, 'name', Class(name).Enumerable());\n        }\n    });\n\n\n    var dylan = new Boy('Dylan', true);\n    dylan.talk(); // Hi my name is Dylan, i'm alive :)\n\n\n    // internal structure of the «dylan» Boy instanc\n    {\n          isAlive: true            // defined by the LifeForm Class constructor\n        , name: 'Dylan'                     // defined by the Boy constructor\n        , __proto__: {                      // Boy prototype\n            init: function init(){ ... }    \n            , __proto__: {                  // Person prototype\n                __proto__: {                // LifeForm prototype\n                    isAlive: false     // property defined on the LifeForm class\n                    , init: function(){ ... }   \n                    , __proto__: {}         // defualt object prototype\n                }\n            }\n        }\n    }\n\n\n\n    console.log(dylan instanceof Boy);       // true\n    console.log(dylan instanceof Person);    // true\n    console.log(dylan instanceof LifeForm);  // true\n    console.log(dylan instanceof Object);    // true\n    console.log(dylan instanceof Array);     // false\n\n\n\n### Static Methods\n\n#### Class()\n\nif the Class constructor is called without the new Keyword it doesnt create an instance of the class, it does instead return\na class property definition which can be used by the Class.define or Object.defineProperty method.\n\n    Class(234) // {value: 234}\n    Class(true).enumerable() // {value: true, enumerable: true}\n    Class('yeah').writable() // {value: 'yeah', writable: true}\n    Class(new Error('nope')).configurable() // {value: Error, configurable: true} \n    Class(234).enumerable().writable().configurable() // {value: 234, enumerable: true, writable: true, configurable: true}\n\n\n#### Class.define()\n\nThis can be used oin playe of the Object.defineProperty method.\n\n    Class.define({}, 'property_name', {value:3});\n\n#### Class.proto()\n\nReturns the prototype of a class instance\n\n    var prototype = Class.proto(instance);\n\n#### Class.keys()\n\nReturns all enumerable properties of a class instance and of all its prototypes. Object.keys does the same for only the class instance.\n\n    var keys = Class.keys(instance);\n\n\n#### Class.implement()\n\nImplements methods and properties from a classinstance on another object.\n\n    var myObject = {};\n\n    var MyClass = new Class({\n        test: function(){\n\n        }\n    });\n\n    Class.implement(new MyClass(), myObject);\n\n    console.log(myObject); // {test: function(){}}\n\n\n# Version History\n\n- 0.1.0: initial version\n- 0.1.3: fixed integration with eventemitter objects\n- 0.2.0: Added proper implementation for calling super functions, deprecated the «parent» property\n- 0.2.1: Bugfix for the «super implementation»\n- 0.2.2: Deprecated the «super» property and replaced it with the «parent» property beacuse super is a javascript reserved keyword\n- 0.2.3: The constructor takes now n instead of 1 arguments\n- 0.2.4: The constructor may now return a function when overriding the class implementation\n- 0.2.6: Classes expose their defintion now via the «Class.definition» proroperty\n- 0.2.7: Added support fo Object.defineProperties()\n- 0.2.8: Removed all occurences of __proto__ in th eclass implementation, replaced the by Object.getPrototypeOf()\n- 0.3.0: Removed the deprecated «parent» property\n- 0.4.0: Removed the default value passed to a class constructor\n- 1.0.0: Complete rewrite, the implementation is now simpler, faster and more JS like. The api is not 100% compaitble with the old api.\n- 1.0.1: Added more test & docs\n- 1.0.2: Fixed docs\n- 1.0.5: The class contructor function can now return an object as its instance\n- 1.0.6: The class contructor function can now return any type that is not undefined as its instance\n- 1.0.7: If the class inherits from a nativa javascript object, it will map the super of the init function to it",
  "readmeFilename": "README.md",
  "_id": "ee-class@1.0.7",
  "_from": "ee-class@1.0.x"
}
